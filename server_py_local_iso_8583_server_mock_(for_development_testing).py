# -*- coding: utf-8 -*-
"""server.py - Local ISO 8583 Server Mock (For Development/Testing)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nAUg20CWUB7x9jd4Y0wWptrF52WSfoYd
"""

# server.py
# This file provides a mock ISO 8583 server for local development and testing purposes.
# It simulates the behavior of an external ISO 8583 server, processing card authorization
# requests and returning mock responses.
#
# IMPORTANT: This server is for LOCAL DEVELOPMENT/TESTING ONLY and is NOT part of the
# production deployment. Your app.py now directly communicates with a real external
# ISO 8583 server.

import socket
import json
import struct
import logging
import random
import time

# Configure logging for the mock server
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Mock Card Ledger (simulates balances on the ISO 8583 server's side)
# This data would come from a real database/ledger in a production ISO 8583 server.
MOCK_CARD_LEDGER = {
    "4242424242424242": {"balance": 5000000.00, "status": "active", "auth_code_prefix": "123"}, # Example: 5,000,000.00 USD
    "5151515151515151": {"balance": 100000.00, "status": "active", "auth_code_prefix": "456"},  # Example: 100,000.00 USD
    "4000000000000000": {"balance": 50.00, "status": "active", "auth_code_prefix": "789"},    # Low balance card
    "4999999999999999": {"balance": 0.00, "status": "inactive", "auth_code_prefix": "000"},  # Inactive card
}

# Mock response codes for ISO 8583 Field 39
ISO_RESPONSE_CODES = {
    "00": "Approved",
    "05": "Do not honor",
    "14": "Invalid card number",
    "51": "Insufficient funds",
    "91": "Issuer or switch inoperative",
    "99": "Transaction failed (General error)"
}

def generate_mock_auth_code(prefix, length):
    """Generates a mock authorization code based on a prefix and desired length."""
    if len(prefix) > length:
        prefix = prefix[:length]
    remaining_length = length - len(prefix)
    return prefix + ''.join(random.choices('0123456789', k=remaining_length))

def process_iso_message(request_data: dict) -> dict:
    """
    Simulates processing an incoming ISO 8583 authorization request.
    This function acts as the core logic of the mock ISO 8583 server.

    Args:
        request_data (dict): A dictionary representing the parsed ISO 8583 request,
                             expected to contain 'pan', 'amount', 'expiry', 'cvv',
                             'auth_code', 'transaction_id', 'currency_code', 'protocol_type'.

    Returns:
        dict: A dictionary representing the mock ISO 8583 response, with 'status',
              'message', 'field39', 'auth_code', 'transaction_id'.
    """
    logger.info(f"Mock Server: Received request for PAN: {request_data.get('pan', 'N/A')[-4:]}, Amount: {request_data.get('amount')}")

    pan = request_data.get('pan')
    amount_cents = request_data.get('amount') # Amount is expected in cents/smallest unit
    # Convert amount back to float for ledger check
    amount_usd = amount_cents / 100.0 if amount_cents is not None else 0.0

    # Simulate processing delay
    time.sleep(random.uniform(0.5, 2.0))

    card_info = MOCK_CARD_LEDGER.get(pan)

    response_status = "Declined"
    response_message = "Transaction failed (general error)."
    field39 = "99"
    auth_code = ""

    if not card_info:
        response_status = "Declined"
        response_message = "Invalid card number."
        field39 = "14"
    elif card_info["status"] != "active":
        response_status = "Declined"
        response_message = "Card is inactive."
        field39 = "05" # Do not honor
    elif card_info["balance"] < amount_usd:
        response_status = "Declined"
        response_message = "Insufficient funds."
        field39 = "51"
    else:
        # Simulate approval
        response_status = "Approved"
        response_message = "Transaction approved."
        field39 = "00"

        # Generate a mock authorization code based on protocol type (for demo)
        protocol_type = request_data.get('protocol_type', 'POS_101_6') # Default to 101.6 if not provided
        if "4-digit" in protocol_type:
            auth_code = generate_mock_auth_code(card_info.get("auth_code_prefix", ""), 4)
        elif "6-digit" in protocol_type or "Pre-authorization" in protocol_type:
            auth_code = generate_mock_auth_code(card_info.get("auth_code_prefix", ""), 6)
        else:
            auth_code = generate_mock_auth_code(card_info.get("auth_code_prefix", ""), 6) # Default to 6

        # Deduct from mock balance (for demonstration purposes only)
        # In a real system, this would involve atomic database operations.
        MOCK_CARD_LEDGER[pan]["balance"] -= amount_usd
        logger.info(f"Mock Server: Card {pan[-4:]} new balance: {MOCK_CARD_LEDGER[pan]['balance']:.2f}")

    mock_response = {
        "status": response_status,
        "message": response_message,
        "field39": field39,
        "auth_code": auth_code,
        "transaction_id": request_data.get('transaction_id'), # Echo back the transaction ID
        "arn": f"MOCKARN{random.randint(100000000000, 999999999999)}" # Mock ARN
    }
    logger.info(f"Mock Server: Sending response: {mock_response}")
    return mock_response

def start_mock_iso_server(host='127.0.0.1', port=12345):
    """
    Starts the mock ISO 8583 server, listening for TCP connections.
    It expects a 2-byte length header followed by a JSON payload.
    """
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind((host, port))
    server_socket.listen(5)
    logger.info(f"Mock ISO 8583 Server listening on {host}:{port}")

    while True:
        conn, addr = server_socket.accept()
        logger.info(f"Accepted connection from {addr}")
        try:
            # Read 2-byte length header
            length_header = conn.recv(2)
            if not length_header:
                logger.warning("Client disconnected or sent no data.")
                continue

            message_length = struct.unpack('!H', length_header)[0]
            logger.debug(f"Received message length: {message_length} bytes")

            # Read the message body
            message_body = b''
            bytes_received = 0
            while bytes_received < message_length:
                chunk = conn.recv(message_length - bytes_received)
                if not chunk:
                    logger.error("Client disconnected while reading message body.")
                    break
                message_body += chunk
                bytes_received += len(chunk)

            if bytes_received != message_length:
                logger.error(f"Incomplete message received. Expected {message_length}, got {bytes_received}.")
                continue

            try:
                # Decode and parse the JSON payload
                request_data = json.loads(message_body.decode('utf-8'))
                logger.debug(f"Parsed request data: {request_data}")

                # Process the mock transaction
                response_data = process_iso_message(request_data)

                # Prepare response: JSON payload with 2-byte length header
                json_response = json.dumps(response_data).encode('utf-8')
                response_length = len(json_response)
                response_header = struct.pack('!H', response_length)

                full_response = response_header + json_response
                conn.sendall(full_response)
                logger.info(f"Sent {response_length} bytes response to {addr}")

            except json.JSONDecodeError:
                logger.error(f"Received non-JSON or malformed message from client: {message_body.decode('utf-8', errors='ignore')}")
                error_response = {"status": "ERROR", "message": "Invalid request format", "field39": "99"}
                error_json = json.dumps(error_response).encode('utf-8')
                error_header = struct.pack('!H', len(error_json))
                conn.sendall(error_header + error_json)
            except Exception as e:
                logger.error(f"Error processing client request: {e}", exc_info=True)
                error_response = {"status": "ERROR", "message": f"Server internal error: {e}", "field39": "99"}
                error_json = json.dumps(error_response).encode('utf-8')
                error_header = struct.pack('!H', len(error_json))
                conn.sendall(error_header + error_json)
        finally:
            conn.close()
            logger.info(f"Connection with {addr} closed.")

if __name__ == '__main__':
    # Default host and port for the mock server.
    # Your app.py will connect to these if ISO_SERVER_HOST/PORT are not set in its env.
    mock_host = os.environ.get('MOCK_ISO_SERVER_HOST', '127.0.0.1')
    mock_port = int(os.environ.get('MOCK_ISO_SERVER_PORT', 12345)) # Use a different port than 20 to avoid conflicts

    logger.info(f"Starting Mock ISO 8583 Server on {mock_host}:{mock_port}")
    start_mock_iso_server(mock_host, mock_port)