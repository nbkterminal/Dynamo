# -*- coding: utf-8 -*-
"""isocrypto.py - Core Crypto Payout Logic (Real Transactions)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W3oxuICH7L_At-m7XDXf2g7tQxg_ZUkm
"""

# isocrypto.py
# This file handles the core cryptocurrency payout logic using self-custodied wallets
# and direct blockchain interaction via Infura (Ethereum) and Trongrid (Tron).

import os
import time
import random
from web3 import Web3
from web3.middleware import geth_poa_middleware # Potentially useful for some EVM chains
import json # For loading ERC-20 ABI
from tronpy import Tron
from tronpy.providers import HTTPProvider
from tronpy.keys import PrivateKey # For Tron private key handling
import logging

logger = logging.getLogger(__name__)

# --- Load Environment Variables ---
# RPC API Keys (Provided by Infura/Trongrid)
INFURA_API_KEY = os.environ.get('INFURA_API_KEY')
TRONGRID_API_KEY = os.environ.get('TRONGRID_API_KEY')

# WARNING: Storing private keys in environment variables is NOT recommended for production.
# For a real-world application, use a dedicated secret management service
# (e.g., Google Cloud Secret Manager, AWS Secrets Manager, HashiCorp Vault).
# For this trial/demonstration, we use environment variables for simplicity.
ETH_PAYOUT_PRIVATE_KEY = os.environ.get('ETH_PAYOUT_PRIVATE_KEY')
TRX_PAYOUT_PRIVATE_KEY = os.environ.get('TRX_PAYOUT_PRIVATE_KEY')

# --- Initialize RPC Providers ---
# Ethereum (for ERC-20 USDT)
w3_eth = None
if INFURA_API_KEY:
    try:
        # Construct the Infura URL for Ethereum Mainnet
        infura_url = f"https://mainnet.infura.io/v3/{INFURA_API_KEY}"
        w3_eth = Web3(Web3.HTTPProvider(infura_url))

        # Optional: Inject PoA middleware if you were connecting to a Proof-of-Authority
        # network like Polygon, BNB Chain, etc. Ethereum Mainnet is Proof-of-Stake.
        # w3_eth.middleware_onion.inject(geth_poa_middleware, layer=0)

        if not w3_eth.is_connected():
            raise ConnectionError("Failed to connect to Infura Ethereum node.")
        logger.info("Infura Ethereum client initialized successfully.")
    except Exception as e:
        logger.error(f"Error initializing Infura Ethereum client: {e}. ERC20 payouts will be simulated.")
        w3_eth = None
else:
    logger.warning("INFURA_API_KEY not found in environment variables. ERC20 payouts will be simulated.")

# Tron (for TRC-20 USDT)
tron_client = None
if TRONGRID_API_KEY:
    try:
        # Initialize TronPy client with Trongrid API key for Mainnet
        # FIX: Pass 'network' argument directly to Tron constructor, not HTTPProvider
        tron_client = Tron(HTTPProvider(api_key=TRONGRID_API_KEY), network='mainnet')
        # Test connectivity by attempting to get the latest block number (optional, for debugging)
        # tron_client.get_latest_block_number()
        logger.info("Trongrid Tron client initialized successfully.")
    except Exception as e:
        logger.error(f"Error initializing Trongrid Tron client: {e}. TRC20 payouts will be simulated.")
        tron_client = None
else:
    logger.warning("TRONGRID_API_KEY not found in environment variables. TRC20 payouts will be simulated.")

# --- ERC-20 USDT Contract Details (Mainnet) ---
# The official contract address for Tether USDT (ERC-20) on Ethereum Mainnet.
USDT_ERC20_CONTRACT_ADDRESS = Web3.to_checksum_address("0xdAC17F958D2ee523a2206206994597C13D831ec7")

# Minimal ERC-20 ABI for the 'transfer' function.
# This ABI is sufficient for sending tokens. For other interactions (e.g., balanceOf),
# you would need a more complete ABI.
USDT_ERC20_ABI = json.loads('''
[
    {
        "constant": false,
        "inputs": [
            {
                "name": "_to",
                "type": "address"
            },
            {
                "name": "_value",
                "type": "uint256"
            }
        ],
        "name": "transfer",
        "outputs": [
            {
                "name": "",
                "type": "bool"
            }
        ],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
    }
]
''')

# --- TRC-20 USDT Contract Details (Mainnet) ---
# The official contract address for Tether USDT (TRC-20) on Tron Mainnet.
USDT_TRC20_CONTRACT_ADDRESS = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"

# --- Mock Crypto Exchange Rates (USDT is typically pegged to USD, so 1:1) ---
MOCK_USDT_USD_RATE = 1.00 # 1 USDT = 1 USD (stablecoin)

# --- Simulated Network Fees (for display purposes) ---
# These are mock values for displaying potential costs to the user.
# Actual fees will be paid in ETH (for ERC20) or TRX (for TRC20) from your sender wallets.
SIMULATED_ERC20_USDT_FEE = 3.00 # Mock fee in USDT for ERC20 withdrawal
SIMULATED_TRC20_USDT_FEE = 1.00 # Mock fee in USDT for TRC20 withdrawal

def calculate_simulated_gas_fee_usdt(network_type):
    """
    Calculates a simulated gas/network fee in USDT based on the network type.
    This is for displaying a potential cost to the user in the UI.
    """
    if network_type == "ERC20":
        return SIMULATED_ERC20_USDT_FEE
    elif network_type == "TRC20":
        return SIMULATED_TRC20_USDT_FEE
    else:
        logger.warning(f"Unknown crypto network type '{network_type}'. Defaulting to ERC20 simulated fee.")
        return SIMULATED_ERC20_USDT_FEE


def initiate_crypto_payout(fiat_amount, crypto_address, crypto_network_type):
    """
    Initiates a crypto payout to a given recipient address on a specified network.
    Uses self-custodied wallets via Infura (Ethereum) or Trongrid (Tron).
    Falls back to simulation if RPC clients or private keys are not available.
    """
    logger.info(f"Attempting crypto payout for {fiat_amount} USD to {crypto_address} on {crypto_network_type} network.")

    # Convert fiat amount to USDT (assuming 1:1 peg for stablecoin)
    amount_to_send_usdt = fiat_amount * MOCK_USDT_USD_RATE

    # Simulate gas fee for display purposes. Actual gas is paid in ETH/TRX.
    simulated_gas_fee_usdt = calculate_simulated_gas_fee_usdt(crypto_network_type)

    if amount_to_send_usdt <= 0:
        return {
            "status": "Failed",
            "message": "Transaction amount must be greater than zero.",
            "payout_amount_usdt": 0.0,
            "simulated_gas_fee_usdt": simulated_gas_fee_usdt
        }

    # --- ERC-20 (USDT on Ethereum) Payout Logic ---
    if crypto_network_type == "ERC20":
        if not w3_eth or not ETH_PAYOUT_PRIVATE_KEY:
            logger.warning("Infura client or Ethereum private key not available. Falling back to simulation for ERC20.")
            return _simulate_payout(amount_to_send_usdt, simulated_gas_fee_usdt)

        try:
            # Derive sender address from the private key
            sender_account = w3_eth.eth.account.from_key(ETH_PAYOUT_PRIVATE_KEY)
            sender_address = sender_account.address
            logger.info(f"Sending ERC20 USDT from Ethereum address: {sender_address}")

            # Get the ERC-20 contract instance
            usdt_contract = w3_eth.eth.contract(address=USDT_ERC20_CONTRACT_ADDRESS, abi=USDT_ERC20_ABI)

            # Convert USDT amount to the token's smallest unit (USDT has 6 decimals)
            # e.g., 1 USDT = 1,000,000 (10^6) smallest units
            amount_in_smallest_unit = int(amount_to_send_usdt * (10**6))

            # Get current gas price and nonce
            gas_price = w3_eth.eth.gas_price # Current average gas price in Wei
            nonce = w3_eth.eth.get_transaction_count(sender_address)

            # Build the ERC-20 transfer transaction
            # A typical ERC-20 transfer might consume 50,000 - 100,000 gas units.
            # You might want to use w3_eth.eth.estimate_gas() for dynamic estimation in production.
            gas_limit = 100000 # Example gas limit, adjust as needed or estimate dynamically

            transaction = usdt_contract.functions.transfer(
                crypto_address, # Recipient address
                amount_in_smallest_unit
            ).build_transaction({
                'chainId': w3_eth.eth.chain_id,
                'gas': gas_limit,
                'gasPrice': gas_price,
                'nonce': nonce,
            })

            # Sign the transaction with the sender's private key
            signed_txn = w3_eth.eth.account.sign_transaction(transaction, ETH_PAYOUT_PRIVATE_KEY)

            # Send the raw, signed transaction to the Ethereum network via Infura
            tx_hash = w3_eth.eth.send_raw_transaction(signed_txn.rawTransaction)
            tx_hash_hex = tx_hash.hex()
            logger.info(f"ERC20 USDT transaction sent. Transaction Hash: {tx_hash_hex}")

            return {
                "status": "Success",
                "message": f"ERC20 USDT payout initiated. Transaction Hash: {tx_hash_hex}",
                "payout_amount_usdt": amount_to_send_usdt,
                "simulated_gas_fee_usdt": simulated_gas_fee_usdt,
                "transaction_hash": tx_hash_hex
            }

        except Exception as e:
            logger.error(f"Error during ERC20 USDT payout: {e}", exc_info=True)
            return {
                "status": "Failed",
                "message": f"ERC20 USDT payout failed: {e}",
                "payout_amount_usdt": 0.0,
                "simulated_gas_fee_usdt": simulated_gas_fee_usdt
            }

    # --- TRC-20 (USDT on Tron) Payout Logic ---
    elif crypto_network_type == "TRC20":
        if not tron_client or not TRX_PAYOUT_PRIVATE_KEY:
            logger.warning("Trongrid client or Tron private key not available. Falling back to simulation for TRC20.")
            return _simulate_payout(amount_to_send_usdt, simulated_gas_fee_usdt)

        try:
            # Derive sender address from the private key
            priv_key = PrivateKey(bytes.fromhex(TRX_PAYOUT_PRIVATE_KEY))
            sender_address = priv_key.public_key.to_base58check_address()
            logger.info(f"Sending TRC20 USDT from Tron address: {sender_address}")

            # Get the TRC-20 USDT contract instance
            usdt_contract = tron_client.get_contract(USDT_TRC20_CONTRACT_ADDRESS)

            # Convert USDT amount to the token's smallest unit (USDT has 6 decimals on Tron)
            # e.g., 1 USDT = 1,000,000 (10^6) smallest units
            amount_in_smallest_unit = int(amount_to_send_usdt * (10**6))

            # Build the TRC-20 transfer transaction
            # Tron transactions consume Energy and Bandwidth, paid in TRX.
            # fee_limit is in SUN (1 TRX = 1,000,000 SUN). A typical TRC-20 transfer might cost ~20-30 TRX.
            # Set a reasonable fee_limit to cover network costs.
            fee_limit_sun = 30_000_000 # Example: 30 TRX in SUN. Adjust based on network conditions.

            txn = (
                usdt_contract.functions.transfer(crypto_address, amount_in_smallest_unit)
                .with_owner(sender_address) # Specify the sender's address
                .fee_limit(fee_limit_sun) # Set max fee in SUN
                .build()
                .sign(priv_key) # Sign the transaction with the sender's private key
            )

            # Broadcast the transaction to the Tron network via Trongrid
            # .wait() attempts to wait for the transaction to be confirmed on the blockchain
            tx_id = txn.broadcast().wait()
            tx_id_hex = tx_id['id']
            logger.info(f"TRC20 USDT transaction sent. Transaction Hash: {tx_id_hex}")

            return {
                "status": "Success",
                "message": f"TRC20 USDT payout initiated. Transaction Hash: {tx_id_hex}",
                "payout_amount_usdt": amount_to_send_usdt,
                "simulated_gas_fee_usdt": simulated_gas_fee_usdt,
                "transaction_hash": tx_id_hex
            }

        except Exception as e:
            logger.error(f"Error during TRC20 USDT payout: {e}", exc_info=True)
            return {
                "status": "Failed",
                "message": f"TRC20 USDT payout failed: {e}",
                "payout_amount_usdt": 0.0,
                "simulated_gas_fee_usdt": simulated_gas_fee_usdt
            }
    else:
        # Fallback if the crypto_network_type is not recognized or supported
        logger.warning(f"Unsupported crypto network type: {crypto_network_type}. Falling back to simulation.")
        return _simulate_payout(amount_to_send_usdt, simulated_gas_fee_usdt)

def _simulate_payout(amount, simulated_fee):
    """
    Internal helper function for simulating crypto payouts when real API interaction
    is not possible (e.g., missing API keys or private keys).
    """
    logger.warning("Falling back to simulated crypto payout for demonstration/testing.")
    time.sleep(2) # Simulate network delay
    if random.random() < 0.9: # 90% chance of simulated success
        status = "Success"
        message = "Simulated crypto payout successfully initiated (real crypto client not configured)."
        tx_hash = f"SIMULATED_TXN_{os.urandom(16).hex()}"
    else:
        status = "Failed"
        message = "Simulated blockchain network congestion or error."
        tx_hash = ""

    return {
        "status": status,
        "message": message,
        "payout_amount_usdt": amount,
        "simulated_gas_fee_usdt": simulated_fee,
        "transaction_hash": tx_hash
    }
